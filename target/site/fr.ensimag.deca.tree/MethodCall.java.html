<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MethodCall.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Deca Compiler</a> &gt; <a href="index.source.html" class="el_package">fr.ensimag.deca.tree</a> &gt; <span class="el_source">MethodCall.java</span></div><h1>MethodCall.java</h1><pre class="source lang-java linenums">package fr.ensimag.deca.tree;

import fr.ensimag.deca.context.Type;
import fr.ensimag.deca.context.VariableDefinition;
import fr.ensimag.deca.context.Definition;
import fr.ensimag.deca.context.Signature;
import fr.ensimag.deca.context.MethodDefinition;
import fr.ensimag.deca.DecacCompiler;
import fr.ensimag.deca.context.ClassDefinition;
import fr.ensimag.deca.context.ClassType;
import fr.ensimag.deca.context.ContextualError;
import fr.ensimag.deca.context.EnvironmentExp;
import fr.ensimag.deca.tools.IndentPrintStream;
import java.io.PrintStream;
import org.apache.commons.lang.Validate;
import fr.ensimag.deca.tools.SymbolTable.Symbol;
import fr.ensimag.deca.context.Definition;
import fr.ensimag.ima.pseudocode.GPRegister;
import fr.ensimag.ima.pseudocode.Register;
import fr.ensimag.ima.pseudocode.RegisterOffset;
import fr.ensimag.ima.pseudocode.instructions.LOAD;
import fr.ensimag.ima.pseudocode.ImmediateFloat;
import fr.ensimag.ima.pseudocode.instructions.WFLOAT;
import fr.ensimag.ima.pseudocode.instructions.WINT;
import fr.ensimag.ima.pseudocode.DAddr;
import fr.ensimag.deca.context.Signature;
import fr.ensimag.ima.pseudocode.ImmediateInteger;
import fr.ensimag.ima.pseudocode.instructions.ADDSP;
import fr.ensimag.ima.pseudocode.instructions.SUBSP;
import fr.ensimag.ima.pseudocode.instructions.STORE;
import fr.ensimag.ima.pseudocode.instructions.BSR;
import fr.ensimag.ima.pseudocode.instructions.TSTO;
import fr.ensimag.ima.pseudocode.instructions.BOV;
import fr.ensimag.ima.pseudocode.Label;

import org.apache.log4j.Logger;

public class MethodCall extends AbstractExpr {

<span class="fc" id="L40">    private static final Logger LOG = Logger.getLogger(MethodCall.class);</span>

    private AbstractExpr selectExpr;
    private AbstractIdentifier methodName;
    private ListExpr args;

<span class="fc" id="L46">    public MethodCall(AbstractExpr selectExpr, AbstractIdentifier methodName, ListExpr params){</span>
<span class="fc" id="L47">        Validate.notNull(selectExpr);</span>
<span class="fc" id="L48">        Validate.notNull(methodName);</span>
<span class="fc" id="L49">        Validate.notNull(params);</span>
<span class="fc" id="L50">        this.selectExpr = selectExpr;</span>
<span class="fc" id="L51">        this.methodName = methodName;</span>
<span class="fc" id="L52">        this.args = params;</span>
<span class="fc" id="L53">    }</span>

    @Override
    public Type verifyExpr(DecacCompiler compiler, EnvironmentExp localEnv,
            ClassDefinition currentClass) throws ContextualError {
<span class="fc" id="L58">        LOG.debug(&quot;Verify Expr Methodcall: start&quot;);</span>
        /*if (currentClass == null){
            throw new ContextualError(&quot;Classe null idk&quot;, this.getLocation());
        }*/
<span class="fc" id="L62">        ClassType t = (ClassType)selectExpr.verifyExpr(compiler, localEnv, currentClass); // rajouter une exception plus tard</span>
<span class="fc" id="L63">        ClassDefinition class_def = (ClassDefinition)compiler.getDefinition(t.getName());</span>
<span class="fc" id="L64">        EnvironmentExp env_exp2 = class_def.getMembers();</span>

<span class="fc" id="L66">        MethodDefinition methodDef = (MethodDefinition)env_exp2.get(this.methodName.getName());</span>
<span class="fc" id="L67">        Signature sig = methodDef.getSignature();</span>
<span class="fc" id="L68">        Type return_t = methodDef.getType();</span>
<span class="fc" id="L69">        methodName.setDefinition(methodDef);</span>

        //methodName.verifySignature(compiler, localEnv, currentClass, sig);
<span class="fc" id="L72">        int i = 0;</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">        for(AbstractExpr arg : args.getList()){ // verifier cas ou il y a trop de parametres</span>
<span class="fc" id="L74">            Type expected_type = sig.paramNumber(i);</span>
<span class="fc" id="L75">            AbstractExpr new_expr = arg.verifyRValue(compiler, localEnv, currentClass, expected_type);</span>
<span class="fc" id="L76">            arg = new_expr;</span>
<span class="fc" id="L77">            i++;</span>
<span class="fc" id="L78">        }</span>
<span class="fc" id="L79">        this.setType(return_t);</span>
<span class="fc" id="L80">        selectExpr.setType(t);</span>
<span class="fc" id="L81">        LOG.debug(&quot;verify Methodcall: end&quot;);</span>
<span class="fc" id="L82">        return return_t;</span>
    }

    @Override
    public void decompile(IndentPrintStream s) {
<span class="fc" id="L87">        s.print(' ');</span>
<span class="fc" id="L88">    }</span>

    @Override
    protected void prettyPrintChildren(PrintStream s, String prefix) {
<span class="fc" id="L92">        selectExpr.prettyPrint(s, prefix, false);</span>
<span class="fc" id="L93">        methodName.prettyPrint(s, prefix, false);</span>
<span class="fc" id="L94">        args.prettyPrint(s, prefix, true);</span>

<span class="fc" id="L96">    }</span>

    @Override
    protected void iterChildren(TreeFunction f) {
<span class="fc" id="L100">        selectExpr.iter(f);</span>
<span class="fc" id="L101">        methodName.iter(f);</span>
<span class="fc" id="L102">        args.iter(f);</span>
<span class="fc" id="L103">    }</span>
    
    @Override
    protected void codeGenInst(DecacCompiler compiler) {
        //throw new UnsupportedOperationException(&quot;not yet implemented&quot;);
<span class="fc" id="L108">        LOG.debug(&quot;code gen of &quot;+ this.methodName.getName().getName() + &quot;:begin&quot;);</span>
<span class="fc" id="L109">        int method_index = this.methodName.getMethodDefinition().getIndex();</span>
<span class="fc" id="L110">        Signature sig = this.methodName.getMethodDefinition().getSignature();</span>
<span class="fc" id="L111">        int d = sig.size() + 1; // nombre de paramètres</span>
<span class="fc" id="L112">        Definition class_def = compiler.getDefinition(this.selectExpr.getType().getName());</span>
        DAddr var_addr;
<span class="fc" id="L114">        GPRegister r2 = Main.rmanager.getR2();</span>
<span class="fc" id="L115">        GPRegister r3 = Main.rmanager.getRegister();</span>
<span class="fc" id="L116">        Register sp = Main.rmanager.getSP();</span>
<span class="fc" id="L117">        compiler.addInstruction(new TSTO(d));</span>
<span class="fc" id="L118">        compiler.addInstruction(new BOV(new Label(&quot;pile_pleine&quot;)));</span>
<span class="fc" id="L119">        compiler.addInstruction(new ADDSP(new ImmediateInteger(d)));</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if(this.selectExpr.isThis()){</span>
            //throw new UnsupportedOperationException(&quot;not yet implemented : method call in an another method&quot;);
<span class="fc" id="L122">            this.selectExpr.codeGenInst(compiler);</span>
<span class="fc" id="L123">            compiler.addInstruction(new LOAD(r2, r3));</span>
        }
        else{
<span class="fc" id="L126">            Definition var_def = ((AbstractIdentifier)this.selectExpr).getDefinition();</span>
<span class="fc" id="L127">            var_addr = ((VariableDefinition)var_def).getOperand(); // adresse de la variable</span>
<span class="fc" id="L128">            compiler.addInstruction(new LOAD(var_addr, r3));</span>
        }
        
<span class="fc" id="L131">        RegisterOffset sp_0 = new RegisterOffset(0, sp);</span>
<span class="fc" id="L132">        compiler.addInstruction(new STORE(r3, sp_0));</span>
<span class="fc" id="L133">        int i = 1;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for(AbstractExpr expr : this.args.getList()){</span>
<span class="fc" id="L135">            expr.codeGenInst(compiler);</span>
<span class="fc" id="L136">            RegisterOffset sp_position = new RegisterOffset(-i, sp);</span>
<span class="fc" id="L137">            compiler.addInstruction(new STORE(r2, sp_position));</span>
<span class="fc" id="L138">            i++;</span>
<span class="fc" id="L139">        }</span>
<span class="fc" id="L140">        compiler.addInstruction(new LOAD(sp_0, r3));</span>
        // rajouter CMP et verification de déferencement null

<span class="fc" id="L143">        RegisterOffset r3_0 = new RegisterOffset(0, r3);</span>
<span class="fc" id="L144">        compiler.addInstruction(new LOAD(r3_0, r3));</span>

<span class="fc" id="L146">        MethodDefinition method_def = this.methodName.getMethodDefinition();</span>
        //RegisterOffset method_addr = new RegisterOffset(offset, r3); // récuperer l'index de la méthode dans la table des méthodes
<span class="fc" id="L148">        DAddr method_addr = ListDeclClass.list_m_table.getMethodTable((ClassDefinition)class_def).getAddrMethod(method_def); // récupération de l'adresse de la méthode</span>
<span class="fc" id="L149">        compiler.addInstruction(new BSR(method_addr));</span>
<span class="fc" id="L150">        Register r0 = Main.rmanager.getR0();</span>
<span class="fc" id="L151">        compiler.addInstruction(new LOAD(r0, r2));</span>
<span class="fc" id="L152">        compiler.addInstruction(new SUBSP(new ImmediateInteger(d)));</span>
<span class="fc" id="L153">        Main.rmanager.freeRegister(r3);</span>
<span class="fc" id="L154">        LOG.debug(&quot;code gen of &quot;+ this.methodName.getName().getName() + &quot;:end&quot;);</span>
<span class="fc" id="L155">    }</span>
     @Override
    protected void codeGenPrint(DecacCompiler compiler) {
<span class="fc" id="L158">        GPRegister r0 = Main.rmanager.getR0();</span>
<span class="fc" id="L159">        GPRegister r1 = Main.rmanager.getR1();</span>
<span class="fc" id="L160">        GPRegister r2 = Main.rmanager.getR2();</span>
<span class="fc" id="L161">        this.codeGenInst(compiler);</span>
<span class="fc" id="L162">        compiler.addInstruction(new LOAD(r0, r1));</span>
<span class="fc" id="L163">        Type t = this.getType();</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if(t.isInt()){</span>
<span class="fc" id="L165">            compiler.addInstruction(new WINT());</span>
        }
<span class="nc bnc" id="L167" title="All 2 branches missed.">        else if(t.isFloat()){</span>
<span class="nc" id="L168">            compiler.addInstruction(new WFLOAT());</span>
        }
<span class="fc" id="L170">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>