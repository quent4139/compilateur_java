<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDecaLexer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Deca Compiler</a> &gt; <a href="index.source.html" class="el_package">fr.ensimag.deca.syntax</a> &gt; <span class="el_source">AbstractDecaLexer.java</span></div><h1>AbstractDecaLexer.java</h1><pre class="source lang-java linenums">package fr.ensimag.deca.syntax;

import java.io.File;
import java.io.InputStreamReader;
import java.io.IOException;
import java.net.URL;
import java.util.Stack;

import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonToken;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.IntStream;
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.misc.ParseCancellationException;
import org.apache.commons.lang.Validate;
import org.apache.log4j.Logger;

import fr.ensimag.deca.DecacCompiler;
import fr.ensimag.deca.tree.LocationException;

/**
 * This is the super class for the lexer. It is extended by the lexer class
 * generated from DecaLexer.g.
 * 
 * @author gl37, Based on template by Jim Idle - Temporal Wave LLC
 *         (jimi@idle.ws)
 * @date 01/01/2022
 */
public abstract class AbstractDecaLexer extends Lexer {
<span class="fc" id="L33">    private static final Logger LOG = Logger.getLogger(AbstractDecaLexer.class);</span>

    private DecacCompiler decacCompiler;
    private File source;

    public void setSource(File source) {
<span class="fc" id="L39">        this.source = source;</span>
<span class="fc" id="L40">    }</span>

    protected DecacCompiler getDecacCompiler() {
<span class="fc" id="L43">        return decacCompiler;</span>
    }

    public void setDecacCompiler(DecacCompiler decacCompiler) {
<span class="fc" id="L47">        this.decacCompiler = decacCompiler;</span>
<span class="fc" id="L48">    }</span>

    /**
     * If e is linked to an input stream, return the source name for this
     * stream. Otherwise (e.g. user-defined RecognitionException that do not set
     * the input field), return the source name for this Lexer.
     */
    public String getSourceName(RecognitionException e) {
<span class="nc" id="L56">        final IntStream inputStream = e.getInputStream();</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">        if (inputStream != null) {</span>
<span class="nc" id="L58">            return inputStream.getSourceName();</span>
        } else {
<span class="nc" id="L60">            return getSourceName();</span>
        }
    }

    /**
     * Display the list of tokens for the lexer in semi-human-readable form.
     * 
     * This consumes the stream of tokens, hence should never be called if the
     * parser has to read these tokens afterwards.
     * 
     * @return true if the lexer raised an error.
     */
    public boolean debugTokenStream() {
<span class="fc" id="L73">        CommonTokenStream tokens = new CommonTokenStream(this);</span>
        Token t;
<span class="fc" id="L75">        int i = 0;</span>
        try {
<span class="fc bfc" id="L77" title="All 2 branches covered.">            while ((t = tokens.LT(++i)).getType() != Token.EOF) {</span>
<span class="fc" id="L78">                System.out.println(getVocabulary().getSymbolicName(t.getType()) + &quot;: &quot; + t);</span>
            }
<span class="fc" id="L80">        } catch (ParseCancellationException e) {</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">            if (e.getCause() instanceof LocationException) {</span>
<span class="fc" id="L82">                ((LocationException)e.getCause()).display(System.err);</span>
            }
<span class="fc" id="L84">            return true;</span>
<span class="nc" id="L85">        } catch (DecaRecognitionException e) {</span>
<span class="nc" id="L86">            new LocationException(e.getMessage(), e.getLocation()).display(System.err);</span>
<span class="nc" id="L87">            return true;</span>
<span class="fc" id="L88">        }</span>
<span class="fc" id="L89">        return false;</span>
    }

    /**
     * Default constructor for the lexer.
     */
    public AbstractDecaLexer(CharStream input) {
<span class="fc" id="L96">        super(input);</span>
<span class="fc" id="L97">        removeErrorListeners();</span>
<span class="fc" id="L98">        addErrorListener(new DecacErrorListner(input));</span>
<span class="fc" id="L99">    }</span>

    /**
     * Helper for test drivers, that creates a lexer from command-line
     * arguments.
     * 
     * @param args
     *            Either empty (read from stdin), or 1-element array (the file
     *            to read from)
     * @return The lexer built from args
     * @throws IOException
     */
    public static DecaLexer createLexerFromArgs(String[] args)
            throws IOException {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        Validate.isTrue(args.length &lt;= 1, &quot;0 or 1 argument expected.&quot;);</span>
        DecaLexer lex;
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (args.length == 1) {</span>
<span class="fc" id="L116">            lex = new DecaLexer(CharStreams.fromFileName(args[0]));</span>
<span class="fc" id="L117">            lex.setSource(new File(args[0]));</span>
        } else {
<span class="nc" id="L119">            System.err.println(&quot;Reading from stdin ...&quot;);</span>
<span class="nc" id="L120">            lex = new DecaLexer(CharStreams.fromStream(System.in));</span>
        }
<span class="fc" id="L122">        return lex;</span>
    }

    protected File getSource() {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (getDecacCompiler() != null</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">                &amp;&amp; getDecacCompiler().getSource() != null) {</span>
<span class="fc" id="L128">            return getDecacCompiler().getSource();</span>
        } else {
<span class="fc" id="L130">            return source;</span>
        }
    }

    // Code needed to implement the #include directive.
    // Adapted from https://theantlrguy.atlassian.net/wiki/pages/viewpage.action?pageId=2686987
    private static class IncludeSaveStruct {
<span class="fc" id="L137">        IncludeSaveStruct(CharStream input, int line, int charPositionInline) {</span>
<span class="fc" id="L138">            this.input = input;</span>
<span class="fc" id="L139">            this.line = line;</span>
<span class="fc" id="L140">            this.charPositionInLine = charPositionInline;</span>
<span class="fc" id="L141">        }</span>

        /** Which stream to read from */
        public CharStream input;
        /** Where in the stream was the &lt;code&gt;#include&lt;/code&gt; */
        public int line, charPositionInLine;
    }

<span class="fc" id="L149">    private final Stack&lt;IncludeSaveStruct&gt; includes = new Stack&lt;IncludeSaveStruct&gt;();</span>

    /**
     * Look up the file to include in the current directory, or in the
     * $CLASSPATH (either a file or the content of a .jar file).
     * 
     * @return An ANTLR stream to read from
     * @throws IOException
     *             when the file was found but could not be opened
     * @throws IncludeFileNotFound
     *             when the file was not found.
     */
    CharStream findFile(String name) throws IOException,
            IncludeFileNotFound {
        // Look in the directory containing the source file ...
<span class="fc" id="L164">        String dir = &quot;.&quot;; // default value used e.g. when reading from stdin</span>
<span class="fc" id="L165">        File src = getSource();</span>
<span class="pc bpc" id="L166" title="2 of 4 branches missed.">        if (src != null &amp;&amp; src.getParent() != null) {</span>
<span class="fc" id="L167">            dir = src.getParent();</span>
        }
<span class="fc" id="L169">        String full = dir + &quot;/&quot; + name;</span>
<span class="fc" id="L170">        File f = new File(full);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (f.exists()) {</span>
<span class="nc" id="L172">            LOG.debug(&quot;Using local file &quot; + full);</span>
<span class="nc" id="L173">            return CharStreams.fromFileName(full);</span>
        }

        // ... and fall back to the standard library path if not found.
<span class="fc" id="L177">        final URL url = ClassLoader.getSystemResource(&quot;include/&quot; + name);</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (url != null) {</span>
<span class="fc" id="L179">            LOG.debug(&quot;Using library &quot; + url);</span>
            // Use fromReader(Reader, String) to catch the file name --- fromStream(InputStream) does not.
<span class="fc" id="L181">            return CharStreams.fromReader(new InputStreamReader(url.openStream()), url.getFile());</span>
        }

<span class="nc" id="L184">        throw new IncludeFileNotFound(name, this, getInputStream()); // TODO: check this</span>
    }

    /**
     * Apply a &lt;code&gt;#include&lt;/code&gt; directive.
     * 
     * Look up the file &quot;name&quot; using {@link #findFile(String)}, and set the
     * input stream of the lexer to this object. The previous input stream is
     * saved an {@link #includes} and will be restored by {@link #nextToken()}.
     * 
     * @throws IncludeFileNotFound
     *             When the file could not be found or opened.
     * @throws CircularInclude
     *             When an attempt to perform a circular inclusion is done
     */
    void doInclude(String includeDirective) throws IncludeFileNotFound, CircularInclude {
<span class="fc" id="L200">        String name = includeDirective.substring(includeDirective.indexOf('&quot;') + 1,</span>
<span class="fc" id="L201">                includeDirective.lastIndexOf('&quot;'));</span>
<span class="fc" id="L202">        Validate.notNull(name);</span>
<span class="fc" id="L203">        Validate.notEmpty(name);</span>
        CharStream newInput;
        try {
<span class="fc" id="L206">            newInput = findFile(name);</span>
<span class="nc" id="L207">        } catch (IOException e1) {</span>
            // The file is probably there but not readable.
<span class="nc" id="L209">            throw new IncludeFileNotFound(name, this, getInputStream());</span>
<span class="fc" id="L210">        }</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        for (IncludeSaveStruct s : includes) {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (newInput.getSourceName().equals(s.input.getSourceName())) {</span>
<span class="nc" id="L213">                throw new CircularInclude(name, this, this.getInputStream());</span>
            }
<span class="nc" id="L215">        }</span>
<span class="fc" id="L216">        IncludeSaveStruct ss = new IncludeSaveStruct(getInputStream(),</span>
<span class="fc" id="L217">                getLine(), getCharPositionInLine());</span>
<span class="fc" id="L218">        includes.push(ss);</span>
<span class="fc" id="L219">        setInputStream(newInput);</span>
<span class="fc" id="L220">        throw new SkipANTLRPostAction();</span>
    }

    /**
     * Exception used to skip ANTLR code from doInclude to nextToken().
     *
     * The normal call stack looks like:
     * &lt;code&gt;
     * nextToken()
     *  `-&gt; FailOrAccept
     *      +-&gt; LexerActionExecute
     *      |   `-&gt; doInclude()
     *      |        `-&gt; setInputStream() -&gt; reset()
     *      `-&gt; return return prevAccept.dfaState.prediction
     * &lt;/code&gt;
     * Unfortunately, reset() sets dfaState to null hence this crashes.
     *
     * Instead, use this exception to skip the &quot;return&quot; call, and catch the
     * control back in nextToken().
     */
    private static class SkipANTLRPostAction extends RuntimeException {
        private static final long serialVersionUID = 6114145992238256449L;
    }

    /**
     * Override method nextToken for &lt;code&gt;#include&lt;/code&gt; management.
     * @return the next Token which is read in an included files on
     *    a &lt;code&gt;#include&lt;/code&gt;
     */
    @Override
    @SuppressWarnings(&quot;InfiniteRecursion&quot;)
    public Token nextToken() {
        Token token;
        try {
<span class="fc" id="L254">            token = super.nextToken();</span>
<span class="fc" id="L255">        } catch (SkipANTLRPostAction e) {</span>
            // It's OK, we just found a #include statement.
<span class="fc" id="L257">            return this.nextToken();</span>
<span class="fc" id="L258">        }</span>

<span class="fc bfc" id="L260" title="All 4 branches covered.">        if (token.getType() == Token.EOF &amp;&amp; !includes.empty()) {</span>
            // We've got EOF and have non empty stack.
<span class="fc" id="L262">            LOG.debug(&quot;End of file, poping include stack&quot;);</span>
<span class="fc" id="L263">            IncludeSaveStruct ss = includes.pop();</span>
<span class="fc" id="L264">            setInputStream(ss.input);</span>
<span class="fc" id="L265">            setLine(ss.line);</span>
<span class="fc" id="L266">            setCharPositionInLine(ss.charPositionInLine);</span>

            // this should be used instead of super [like below] to
            // handle exits from nested includes. It matters, when the
            // 'include' token is the last in previous stream (using
            // super, lexer 'crashes' returning EOF token)
<span class="fc" id="L272">            token = this.nextToken();</span>
        }

        // Skip first token after switching on another input.
        // You need to use this rather than super as there may be nested include
        // files
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (((CommonToken) token).getStartIndex() &lt; 0) {</span>
<span class="nc" id="L279">            token = this.nextToken();</span>
        }

<span class="fc" id="L282">        return token;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>